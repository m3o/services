<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>The simplest way to build, share and collaborate on microservices</description>
    <link>https://micro.mu//blog/</link>
    <atom:link href="https://micro.mu//blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 06 May 2020 04:07:34 +0100</pubDate>
    <lastBuildDate>Wed, 06 May 2020 04:07:34 +0100</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Announcing: M3O - A Micro services development platform</title>
        <description>&lt;p&gt;&lt;br /&gt;
Today we’re announcing M3O - a cloud native platform for Micro services development. A vastly simpler method of building distributed systems in the Cloud and beyond without having to manage the infrastructure. M3O (pronounced “em-3-oh” and derived from the word &lt;code&gt;M[icr]o&lt;/code&gt;) is the culmination of many years of experience doing distributed systems development and today we want to shed more light on what we’re working on.&lt;/p&gt;

&lt;p&gt;Before we do, let’s talk about how we got here and what developers have had to deal with over the past decade, as all attempts to focus on software development has been thwarted by the new era of Cloud computing.
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cloud-native-development-is-just-too-complex&quot;&gt;Cloud native development is just too complex&lt;/h2&gt;

&lt;p&gt;Let’s surmise in one sentence, we think modern application development is just too complicated. Building for the cloud has now gone from spinning up a VM via an API to throwing everything and the kitchen sink at container orchestration platforms and the surrounding dumbfounding ecosystem of tools governed by the &lt;a href=&quot;https://www.cncf.io/&quot;&gt;CNCF&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Gone are the days of launching a successful company on a shared PHP host, or being content with &lt;a href=&quot;https://books.google.hu/books?id=ja1KDAAAQBAJ&amp;amp;pg=PA134&amp;amp;lpg=PA134&quot;&gt;restarting ones Ruby server every hour&lt;/a&gt; due to memory leaks, and still becoming the literal behemoth and utility that Twitter became back in 09.&lt;/p&gt;

&lt;p&gt;Somehow between the disparate contribution of technologies to the Cloud ecosystem from startups and the thousands of features now promoted by AWS, the ease of use for the developer has drastically suffered. In fact we argue, the cognitive load on the developer is now so bad that we cannot even begin to start building software for the cloud without 3-6 months of wrangling a kubernetes cluster on one of the incumbent cloud providers, while muddling our way through CloudFormation and walls of YAML…&lt;/p&gt;

&lt;p&gt;Or perhaps it’s a form of decision paralysis due to the explosion of available technologies. In this fast moving industry one often can’t help but follow the technologies provided by FAANGs in a “Nobody got fired for using IBM” spirit. Or the thousand open source projects listed on the CNCF landscape which give us FOMO and a headache all at the same time as we figure out if any of its needed or all of it.&lt;/p&gt;

&lt;h2 id=&quot;so-what-now&quot;&gt;So what now?&lt;/h2&gt;

&lt;p&gt;We are self aware enough to realise our thinking might run critically close to the &lt;a href=&quot;https://xkcd.com/927/&quot;&gt;XKCD comic about standards&lt;/a&gt;. We are also idealistic, (or crazy/bold/ambitious, it’s for the dear reader to decide), enough to believe, we as a tiny startup of misfits can provide a leaner approach to other startups to build services for the Cloud era.&lt;/p&gt;

&lt;p&gt;Being a small team, we hope to be the David against the Goliaths and provide a unifying, overarching vision for the whole workflow from local to cloud and all steps in between, while adamantly keeping the Holy Grail of developer happiness in mind.&lt;/p&gt;

&lt;p&gt;We did not always want to get into the platform business. In fact we desperately tried to avoid doing it at all costs, knowing how PaaS has played out before us. Unfortunately seeing what the status quo has become and having experienced a better world at companies like Google, Hailo and Monzo, we knew it was on us to do something about it.&lt;/p&gt;

&lt;p&gt;There were some times over the past few years where we thought technologies like AWS lambda and Google Cloud functions would push serverless in a direction that would solve for all the developers problems but this was wishful thinking. What we came away with was the realisation that developers don’t want to and shouldn’t have to manage infrastructure. But functions was the wrong development model.&lt;/p&gt;

&lt;h2 id=&quot;a-platform-for-micro-services-development&quot;&gt;A platform for Micro services development&lt;/h2&gt;

&lt;p&gt;Micro started life as a Go framework for microservices development. To solve the problem of distributed systems development with a developer first focus. It took the approach of solving this problem in the smallest way possible. Now though, we find ourselves evolving and moving on to becoming both a &lt;a href=&quot;https://micro.mu/blog/2020/05/04/introducing-micro-server.html&quot;&gt;Runtime&lt;/a&gt; and a Platform.&lt;/p&gt;

&lt;p&gt;M3O is a platform for Micro services development. A fully managed cloud platform which eliminates the need for developers to touch infrastructure and lets them get back to focusing on product and service development. The best kept secret of every successful technology company is now being opened to the world to use as a simply priced hosted platform.&lt;/p&gt;

&lt;p&gt;Our goal is to focus on the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Developer productivity - enabling devs to just focus on building services&lt;/li&gt;
  &lt;li&gt;Collaboration and reuse - the platform is built for teams and sharing of services between them&lt;/li&gt;
  &lt;li&gt;Everything as a Service - all applications on the platform are built as Micro services&lt;/li&gt;
  &lt;li&gt;Velocity of development - we’re building an environment that allows you to move at a blistering pace&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Judging the industry by our primary focus on simplicity, developer productivity and happiness (concepts we believe to be very correlated), we see constant ebbs and flows. One stride towards a positive direction is cancelled out by the introduction and promotion of overly complex tools, or at least the promotion of overly complex tools to the wrong audience and for the wrong usecase.&lt;/p&gt;

&lt;p&gt;Naturally, with millions of us working in this industry, we can’t and don’t expect everything to go the way we envision - we just enthusiastically wish for it. Our industry is still very young, and we all work hard to make it and the world a better place. That being said, we hope our hard work and decades of collective experience with microservices will result in something that the users will love and put to productive use.&lt;/p&gt;

&lt;h2 id=&quot;who-are-we&quot;&gt;Who are we?&lt;/h2&gt;

&lt;p&gt;We are a collective of engineers who have experienced the woes of cloud-native complexity, built platforms before the era of containers and fire fought battles with Kubernetes on multiple cloud providers. We are the every-man, the every-day engineer, who just so happens to now want to do something to combat the complexity that AWS, Google and others have introduced to the world.&lt;/p&gt;

&lt;p&gt;Micro is and always was, an opinionated framework and ecosystem. Convention over configuration. Easy bootstrapping with zero dependencies locally. Filling in blanks as demands of scaling and resiliency comes up - by switching out implementations of interfaces with more sophisticated ones - that was always the Micro way.&lt;/p&gt;

&lt;p&gt;With M3O we plan to keep this approach, working both ways: moving things from local to prod, or prod to local should be a breeze. Micro is particularly well suited for this as an ecosystem built around the use of pluggable abstractions. One of our main goals is to make handling multi environments as easy as possible - regardless of where and how the services are being run, managing and interacting with them should feel just as native as running them on your laptop or PC.&lt;/p&gt;

&lt;p&gt;We try to make it so when someone learns how to use Micro locally, deploying to M3O will not be further away then a CLI command (assuming an account on M3O exists). This reuse of the well known and already useful things that are part of the daily workflow will hopefully provide the easiest way for developers to migrate from local to prod or vice versa.&lt;/p&gt;

&lt;p&gt;We make a promise to you. We will never ask you to run or touch Kubernetes. You have our word. Because we also know that pain.&lt;/p&gt;

&lt;h2 id=&quot;what-is-m3o&quot;&gt;What is M3O?&lt;/h2&gt;

&lt;p&gt;The M3O platform initially will be providing &lt;a href=&quot;https://github.com/micro/micro&quot;&gt;Micro&lt;/a&gt; as a Service. A hosted offering of the open source project which will be billed on a monthly subscription basis. We’ll build the platform so you can build the product. Rather than thinking about infrastructure management, we want you to focus on service development. You’ll never have to touch infrastructure ever again.&lt;/p&gt;

&lt;p&gt;Later on we’ll look to introduce collaboration features and value add services so you don’t have to build them yourself. Email, sms, payments, user management, etc. We’ve got you covered.&lt;/p&gt;

&lt;p&gt;For existing users who already have their own live setup, perhaps easy to configure custom environments (staging, testing or even per engineer environments) will provide enough value to try us out. Or if you’re perfectly happy with your current setup, maybe they using M3O for the next project to save bootstrapping time and cost.&lt;/p&gt;

&lt;h2 id=&quot;what-next&quot;&gt;What next?&lt;/h2&gt;

&lt;p&gt;We invite the reader to &lt;a href=&quot;https://micro.mu/signup&quot;&gt;signup&lt;/a&gt; to the beta which we’ll be providing access to in the coming weeks. We’ll have a community tier for open source software so M3O will be easy to test drive without strings attached. If you’re interested to learn more come join us on &lt;a href=&quot;https://slack.micro.mu&quot;&gt;slack&lt;/a&gt; in the #platform channel.&lt;/p&gt;

&lt;p&gt;Thanks for reading.&lt;/p&gt;

&lt;p&gt;Cheers&lt;/p&gt;

&lt;p&gt;The Micro Team&lt;/p&gt;
</description>
        <pubDate>Tue, 05 May 2020 11:00:00 +0100</pubDate>
        <link>https://micro.mu//blog/2020/05/05/m3o-micro-services-development-platform.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2020/05/05/m3o-micro-services-development-platform.html</guid>
        
        
      </item>
    
      <item>
        <title>Micro Server - Getting started with microservices</title>
        <description>&lt;p&gt;&lt;br /&gt;
In this post we will have a look at how to run and manage microservices locally with &lt;code&gt;micro server&lt;/code&gt; and the Micro CLI in general.
The Micro CLI consists of both the server command and other client commands that enable us to interact with the server.
&lt;code&gt;micro server&lt;/code&gt; can run microservices in different environments - binaries locally for speed and simplicity, or containers in a more production ready environment.&lt;/p&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;Using Go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;go install github.com/micro/micro/v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or by downloading the binary&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# MacOS
curl -fsSL https://raw.githubusercontent.com/micro/micro/master/scripts/install.sh | /bin/bash

# Linux
wget -q  https://raw.githubusercontent.com/micro/micro/master/scripts/install.sh -O - | /bin/bash

# Windows
powershell -Command &quot;iwr -useb https://raw.githubusercontent.com/micro/micro/master/scripts/install.ps1 | iex&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;running-a-service&quot;&gt;Running a service&lt;/h2&gt;

&lt;p&gt;Before diving into writing a service, let’s run an existing one, because it’s just a few commands away!&lt;/p&gt;

&lt;p&gt;First, we have to start the &lt;code&gt;micro server&lt;/code&gt;. The command to do that is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;micro server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To talk to this server, we just have to tell Micro CLI to address our server instead of using the default implementations - micro can work without a server too, but &lt;a href=&quot;#-environments&quot;&gt;more about that later&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The following command tells the CLI to talk to our server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;micro env set server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! We are ready to roll. Just to verify that everything is in order, let’s see what services are running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ micro list services
go.micro.api
go.micro.auth
go.micro.bot
go.micro.broker
go.micro.config
go.micro.debug
go.micro.network
go.micro.proxy
go.micro.registry
go.micro.router
go.micro.runtime
go.micro.server
go.micro.web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All those services are ones started by our &lt;code&gt;micro server&lt;/code&gt;. This is pretty cool, but still it’s not something we launched! Let’s start a service for which existence we can actually take credit for. If we go to &lt;a href=&quot;https://github.com/micro/services&quot;&gt;github.com/micro/services&lt;/a&gt;, we see a bunch of services written by micro authors. One of them is the &lt;code&gt;helloworld&lt;/code&gt;. Try our luck, shall we?&lt;/p&gt;

&lt;p&gt;The command to run services is &lt;code&gt;micro run&lt;/code&gt;. This command may take a while as it checks out
the repository from GitHub. (@todo this actually fails currently, fix)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;micro run github.com/micro/services/helloworld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we take a look at the running &lt;code&gt;micro server&lt;/code&gt;, we should see something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Creating service helloworld version latest source /tmp/github.com-micro-services/helloworld
Processing create event helloworld:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also have a look at logs of the service to verify it’s running.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ micro logs helloworld
Starting [service] go.micro.service.helloworld
Server [grpc] Listening on [::]:36577
Registry [service] Registering node: go.micro.service.helloworld-213b807a-15c2-496f-93ac-7949ad38aadf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So since our service is running happily, let’s try to call it! That’s what services are for.&lt;/p&gt;

&lt;h2 id=&quot;calling-a-service&quot;&gt;Calling a service&lt;/h2&gt;

&lt;p&gt;We have a couple of options to call a service running on our &lt;code&gt;micro server&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;calling-a-service-from-cli&quot;&gt;Calling a service from CLI&lt;/h3&gt;

&lt;p&gt;The easiest is perhaps with the CLI:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ micro call go.micro.service.helloworld Helloworld.Call '{&quot;name&quot;:&quot;Jane&quot;}'
{
	&quot;msg&quot;: &quot;Hello Jane&quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That worked! If we wonder what endpoints a service has we can run the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;micro get service go.micro.service.helloworld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise the best place to look is at the &lt;a href=&quot;https://github.com/micro/services/blob/master/helloworld/proto/helloworld/helloworld.proto&quot;&gt;proto definition&lt;/a&gt;. You can also browse to the UI at &lt;a href=&quot;http://localhost:8082/service/go.micro.service.helloworld&quot;&gt;http://localhost:8082&lt;/a&gt; to see live info.&lt;/p&gt;

&lt;h3 id=&quot;calling-a-service-with-go-micro&quot;&gt;Calling a service with Go Micro&lt;/h3&gt;

&lt;p&gt;Let’s write a small client we can use to call the helloworld service.
Normally you’ll make a service call inside another service so this is just a sample of a function you may write. We’ll &lt;a href=&quot;#-writing-a-service&quot;&gt;learn how to write a full fledged service soon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s take the following file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;context&quot;
	&quot;fmt&quot;

	&quot;github.com/micro/go-micro/v2&quot;
	proto &quot;github.com/micro/services/helloworld/proto&quot;
)

func main() {
	// create and initialise a new service
	service := micro.NewService()
	service.Init()

	// create the proto client for helloworld
	client := proto.NewHelloworldService(&quot;go.micro.service.helloworld&quot;, service.Client())

	// call an endpoint on the service
	rsp, err := client.Call(context.Background(), &amp;amp;proto.Request{
		Name: &quot;John&quot;,
	})
	if err != nil {
		fmt.Println(&quot;Error calling helloworld: &quot;, err)
		return
	}

	// print the response
	fmt.Println(&quot;Response: &quot;, rsp.Msg)
	
	// let's delay the process for exiting for reasons you'll see below
	time.Sleep(time.Second * 5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save the example locally. For ease of following this guide, name the folder &lt;code&gt;example-service&lt;/code&gt;.
After doing a &lt;code&gt;cd example-service &amp;amp;&amp;amp; go mod init example&lt;/code&gt;, we are ready to run this service with &lt;code&gt;micro run&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;micro run .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An other useful command to see what is running, is &lt;code&gt;micro status&lt;/code&gt;. At this point we should have two services running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ micro status
NAME			VERSION	SOURCE										STATUS		BUILD	UPDATED		METADATA
example-service	latest	/home/username/example-service				starting	n/a		4s ago		owner=n/a,group=n/a
helloworld		latest	/tmp/github.com-micro-services/helloworld	running		n/a		6m5s ago	owner=n/a,group=n/a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, since our example-service client is also running, we should be able to see it’s logs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ micro logs example-service
# some go build output here
Response:  Hello John
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! That response is coming straight from the helloworld service we started earlier!&lt;/p&gt;

&lt;h3 id=&quot;from-other-languages&quot;&gt;From other languages&lt;/h3&gt;

&lt;p&gt;In the &lt;a href=&quot;https://github.com/micro/clients&quot;&gt;clients repo&lt;/a&gt; there are Micro clients for various languages and frameworks. They are designed to connect easily to the live Micro environment or your local one, but more about environments later.&lt;/p&gt;

&lt;h2 id=&quot;writing-a-service&quot;&gt;Writing a service&lt;/h2&gt;

&lt;p&gt;To scaffold a new service, the &lt;code&gt;micro new&lt;/code&gt; command can be used. It should output something
reasonably similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ micro new foobar
Creating service go.micro.service.foobar in foobar

.
├── main.go
├── generate.go
├── plugin.go
├── handler
│   └── foobar.go
├── subscriber
│   └── foobar.go
├── proto/foobar
│   └── foobar.proto
├── Dockerfile
├── Makefile
├── README.md
├── .gitignore
└── go.mod


download protobuf for micro:

brew install protobuf
go get -u github.com/golang/protobuf/proto
go get -u github.com/golang/protobuf/protoc-gen-go
go get github.com/micro/micro/v2/cmd/protoc-gen-micro@master

compile the proto file foobar.proto:

cd foobar
protoc --proto_path=.:$GOPATH/src --go_out=. --micro_out=. proto/foobar/foobar.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen from the output above, before building the first service, the following tools must be installed:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://google.github.io/proto-lens/installing-protoc.html&quot;&gt;protoc&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;github.com/golang/protobuf/protoc-gen-go&quot;&gt;protobuf/proto&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;github.com/golang/protobuf/protoc-gen-go&quot;&gt;protoc-gen-micro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They are all needed to translate proto files to actual Go code.
Protos exist to provide a language agnostic way to describe service endpoints, their input and output types, and to have an efficient serialization format at hand.&lt;/p&gt;

&lt;p&gt;Currently Micro is  Go focused (apart from the &lt;a href=&quot;#-from-other-languages&quot;&gt;clients&lt;/a&gt; mentioned before), but this will change soon.&lt;/p&gt;

&lt;p&gt;So once all tools are installed, being inside the service root, we can issue the following command to generate the Go code from the protos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protoc --proto_path=.:$GOPATH/src --go_out=. --micro_out=. proto/foobar/foobar.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The generated code must be committed to source control, to enable other services to import the proto when making service calls (see previous section &lt;a href=&quot;#-calling-a-service&quot;&gt;Calling a service&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At this point, we know how to write a service, run it, and call other services too.
We have everything at our fingertips, but there are still some missing pieces to write applications. One of such pieces is the store interface, which helps with persistent data storage even without a database.&lt;/p&gt;

&lt;h2 id=&quot;storage&quot;&gt;Storage&lt;/h2&gt;

&lt;p&gt;Amongst many other useful built-in services Micro includes a persistent storage service for storing data.&lt;/p&gt;

&lt;h3 id=&quot;interfaces-as-building-blocks&quot;&gt;Interfaces as building blocks&lt;/h3&gt;

&lt;p&gt;A quick side note. Micro (the server/CLI) and Go Micro (the framework) are centered around strongly defined interfaces which are pluggable and provide an abstraction for underlying distributed systems concepts. What does this mean?&lt;/p&gt;

&lt;p&gt;Let’s take our current case of the &lt;a href=&quot;https://github.com/micro/go-micro/blob/master/store/store.go&quot;&gt;store interface&lt;/a&gt;. It’s aimed to enable service writers data storage with a couple of different implementations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;in memory&lt;/li&gt;
  &lt;li&gt;file storage (default when running &lt;code&gt;micro server&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;cockroachdb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Similarly, the &lt;a href=&quot;https://github.com/micro/go-micro/blob/master/runtime/runtime.go&quot;&gt;runtime&lt;/a&gt; interface, that allows you to run services in a completely runtime agnostic way has a few implementations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;local, which just runs actual processes - aimed at local development&lt;/li&gt;
  &lt;li&gt;kubernetes - for running containers in a highly available and distributed way&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is a recurring theme across Micro interfaces. Let’s take a look at the default store when running &lt;code&gt;micro server&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;using-the-store&quot;&gt;Using the Store&lt;/h3&gt;

&lt;h4 id=&quot;using-the-store-with-cli&quot;&gt;Using the store with CLI&lt;/h4&gt;

&lt;p&gt;First, let’s go over the more basic store CLI commands.&lt;/p&gt;

&lt;p&gt;To save a value, we use the write command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;micro store write key1 value1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The UNIX style no output meant it was happily saved. What about reading it?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ micro store read key1
val1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or to display it in a fancier way, we can use the &lt;code&gt;--verbose&lt;/code&gt; or &lt;code&gt;-v&lt;/code&gt; flags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KEY    VALUE   EXPIRY
key1   val1    None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This view is especially useful when we use the &lt;code&gt;--prefix&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; flag, which lets us search for entries which key have certain prefixes.&lt;/p&gt;

&lt;p&gt;To demonstrate that first let’s save an other value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;micro store write key2 val2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this, we can list both &lt;code&gt;key1&lt;/code&gt; and &lt;code&gt;key2&lt;/code&gt; keys as they both share commond prefixes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ micro store read --prefix --verbose key
KEY    VALUE   EXPIRY
key1   val1    None
key2   val2    None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are more to the store, but this knowledge already enables us to be dangerous!&lt;/p&gt;

&lt;h4 id=&quot;using-the-store-with-go-micro&quot;&gt;Using the Store with Go-Micro&lt;/h4&gt;

&lt;p&gt;Accessing the same data we have just manipulated from our Go Micro services could not be easier.
First let’s create an entry that our service can read. This time we will specify the table for the &lt;code&gt;micro store write&lt;/code&gt; command too, as each service has its own table in the store:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;micro store write --table go.micro.service.example mykey &quot;Hi there&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s modify &lt;a href=&quot;#-calling-a-service-with-go-micro&quot;&gt;the example service we wrote previously&lt;/a&gt; so instead of calling a service, it reads the above value from a store.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;fmt&quot;
	&quot;time&quot;

	&quot;github.com/micro/go-micro/v2&quot;
)

func main() {
	service := micro.NewService()

	service.Init(micro.Name(&quot;go.micro.service.example&quot;))

	records, err := service.Options().Store.Read(&quot;mykey&quot;)
	if err != nil {
		fmt.Println(&quot;Error reading from store: &quot;, err)
	}

	if len(records) == 0 {
		fmt.Println(&quot;No records&quot;)
	}
	for _, record := range records {
		fmt.Printf(&quot;key: %v, value: %v\n&quot;, record.Key, string(record.Value))
	}

	time.Sleep(1 * time.Hour)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are almost done! But first we have to learn how to update a service.&lt;/p&gt;

&lt;h2 id=&quot;updating-and-killing-a-service&quot;&gt;Updating and killing a service&lt;/h2&gt;

&lt;p&gt;Now since the example service is running (can be easily verified by &lt;code&gt;micro status&lt;/code&gt;), we should not use &lt;code&gt;micro run&lt;/code&gt;, but rather &lt;code&gt;micro update&lt;/code&gt; to deploy it.&lt;/p&gt;

&lt;p&gt;We can simply issue&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;micro update .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And verify both with the micro server output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Updating service example-service version latest source /home/username/example-service
Processing update event example-service:latest in namespace default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and micro status:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ micro status example-service
NAME			VERSION	SOURCE							STATUS		BUILD	UPDATED		METADATA
example-service	latest	/home/username/example-service	starting	n/a		10s ago		owner=n/a,group=n/a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;that it was updated.&lt;/p&gt;

&lt;p&gt;If things for some reason go haywire, we can try the time tested “turning it off and on again” solution and do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;micro kill .
micro run .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to start with a clean slate.&lt;/p&gt;

&lt;p&gt;So once we did update the example service, we should see the following in the logs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ micro logs example-service
key: mykey, value: Hi there
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice! The example service read the value from the store successfully.&lt;/p&gt;

&lt;h2 id=&quot;clients&quot;&gt;Clients&lt;/h2&gt;

&lt;p&gt;Beyond this we’re working on multi-language clients which you can find and contribute to 
on github at &lt;a href=&quot;https://github.com/micro/clients&quot;&gt;github.com/micro/clients&lt;/a&gt;. We’d love to 
discuss this further but it’s not quite ready.&lt;/p&gt;

&lt;h2 id=&quot;further-reading&quot;&gt;Further reading&lt;/h2&gt;

&lt;p&gt;This is just a brief getting started guide for quickly getting up and running with Micro. 
Come back from time to time to learn more as this guide gets continually upgraded. If you’re 
interested in learning more Micro magic, have a look at the following sources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Read the &lt;a href=&quot;https://micro.mu.docs&quot;&gt;docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Learn by &lt;a href=&quot;https://github.com/micro/examples&quot;&gt;examples&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Come join us on &lt;a href=&quot;https://slack.micro.mu&quot;&gt;Slack&lt;/a&gt; and ask quesions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cheers&lt;/p&gt;

&lt;p&gt;From the team at Micro&lt;/p&gt;
</description>
        <pubDate>Tue, 05 May 2020 11:00:00 +0100</pubDate>
        <link>https://micro.mu//blog/2020/05/05/getting-started-with-microservices.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2020/05/05/getting-started-with-microservices.html</guid>
        
        
      </item>
    
      <item>
        <title>Introducing Micro Server</title>
        <description>&lt;p&gt;&lt;br /&gt;
In 2015, &lt;code&gt;go-micro&lt;/code&gt;, a Go microservices framework was announced. Today we introduce the &lt;code&gt;micro server&lt;/code&gt;, which builds on top of &lt;code&gt;go-micro&lt;/code&gt;, and enables you to run and manage microservices with ease, both locally and across different environments.&lt;/p&gt;

&lt;p&gt;Whether you are running the &lt;code&gt;micro server&lt;/code&gt; locally with zero dependencies (using memory or files), or on k8s (with highly available distributed systems and other third party tools), the &lt;code&gt;micro server&lt;/code&gt; and the micro cli should provide a straightforward and runtime agnostic experience that is the same across any environment.&lt;/p&gt;

&lt;p&gt;For those who prefer action to words, the &lt;a href=&quot;https://micro.mu/docs/getting-started.html&quot;&gt;getting started guide&lt;/a&gt;! can give a taste of what the &lt;code&gt;micro server&lt;/code&gt; is about or visit the project on &lt;a href=&quot;https://github.com/micro/micro&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center; width: 100%;&quot;&gt;
  &lt;img src=&quot;https://micro.mu/images/runtime10.svg&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;combining-a-decade-of-research&quot;&gt;Combining a decade of research&lt;/h2&gt;

&lt;p&gt;At Google in 2011, Asim Aslam, the creator of Micro, experienced what it was like to build systems at Google scale. Google operated a microservices architecture before most ever knew what the term meant. They did this because of an organisational and technical need to build systems that could be developed and managed independently.&lt;/p&gt;

&lt;p&gt;In 2013 a few of us worked at a company called Hailo - a European Uber competitor - one of the few companies that followed Neflix’s model to build an organisational architecture based on microservices. This enabled us to become - at the time - to be incredibly productive and arguably the most successful taxi app in Europe.&lt;/p&gt;

&lt;p&gt;Years later, ex-Hailo members brought the fruits of years of microservices R&amp;amp;D done at Hailo to companies like Monzo, Sixt and many others. We at the Micro team are working on bringing these ideas to the Open Source community. The source of our passion is both the fact that microservices enable companies to be successful and also that we have collectively seen many dozens of companies building similar systems from scratch. Some successfully, some not so successfully.&lt;/p&gt;

&lt;h2 id=&quot;complexity-in-the-age-of-cloud-computing&quot;&gt;Complexity in the age of cloud computing&lt;/h2&gt;

&lt;p&gt;We primarily exist to ensure company and developer success - the advantages of microservices became clear to the industry in the past years, but the tooling around it was and is still in infancy. Breaking up the monolith to different processes comes with an increase in &lt;a href=&quot;https://en.wikipedia.org/wiki/No_Silver_Bullet&quot;&gt;accidental complexity&lt;/a&gt;, which, without appropriate tooling can cause non-negligible amounts of pain. Micro’s mission is to make this pain go away, and unlock a whole new era of computing where services play as nicely together as functions in a programming language do.&lt;/p&gt;

&lt;p&gt;We also aim to help working with different environments (ie local/custom envs/prod) and tools (different databases, orchestration systems etc.), so similar concepts and interfaces can be reused across them.&lt;/p&gt;

&lt;p&gt;There is no question that most local and production setups vastly differ.
The differences dictated by resiliency and scaling requirements and available computing resources creates a disconnect between the different steps during the lifecycle of a code change - from the moment of its birth locally to different environments and ending up in production.&lt;/p&gt;

&lt;p&gt;A simple file backed persistent on a single node is “not enough” in production settings, but similarly you might not want to install and maintain kubernetes or a different heavy container based solution locally.&lt;/p&gt;

&lt;p&gt;This is one of the many areas of modern microservices based workflows that Micro aims to simplify, and our current focus with the &lt;code&gt;micro server&lt;/code&gt; release. There are many more concepts we plan to explore, so if you are interested, stay tuned for further developments.&lt;/p&gt;

&lt;h2 id=&quot;to-end&quot;&gt;To end&lt;/h2&gt;

&lt;p&gt;If you’re interested in the future of cloud-native development, microservices and distributed systems come join us in the community. You can find us in our &lt;a href=&quot;https://slack.micro.mu&quot;&gt;Slack channel&lt;/a&gt; or on &lt;a href=&quot;https://community.micro.mu/&quot;&gt;Discourse&lt;/a&gt;. We can help you if for any reason you get stuck with our &lt;a href=&quot;https://micro.mu/docs&quot;&gt;docs&lt;/a&gt; or the &lt;a href=&quot;https://micro.mu/docs/getting-started.html&quot;&gt;getting started guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also check out the project on &lt;a href=&quot;https://github.com/micro/micro&quot;&gt;github&lt;/a&gt; and give us a ⭐ if you like it.&lt;/p&gt;

&lt;p&gt;Cheers&lt;/p&gt;

&lt;p&gt;From the team at Micro&lt;/p&gt;
</description>
        <pubDate>Mon, 04 May 2020 10:00:00 +0100</pubDate>
        <link>https://micro.mu//blog/2020/05/04/introducing-micro-server.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2020/05/04/introducing-micro-server.html</guid>
        
        
      </item>
    
      <item>
        <title>Micro v2.0.0 release is out!</title>
        <description>&lt;p&gt;&lt;br /&gt;
We’re happy to announce the release of Micro and Go Micro v2! This release is a major milestone for 
us as we adopt gRPC and embedded NATS by default.&lt;/p&gt;

&lt;p&gt;See the releases here&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/micro/micro/releases/tag/v2.0.0&quot;&gt;https://github.com/micro/micro/releases/tag/v2.0.0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/micro/go-micro/releases/tag/v2.0.0&quot;&gt;https://github.com/micro/go-micro/releases/tag/v2.0.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;evolution&quot;&gt;Evolution&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://micro.mu&quot;&gt;&lt;strong&gt;Micro&lt;/strong&gt;&lt;/a&gt; is 5 years in the making now and through that time the tools in our industry have drastically changed. 
We’re moving towards cloud-native being the defacto standard for how we build software.&lt;/p&gt;

&lt;p&gt;Our vision from day 1 was always around &lt;a href=&quot;https://micro.mu/blog/2016/03/17/introduction.html&quot;&gt;Microservices&lt;/a&gt; and the 
power of what it unlocks insides orgs that buy into this form of development. We also fundamentally believed 
in &lt;a href=&quot;https://micro.mu/blog/2016/03/20/micro.html&quot;&gt;RPC&lt;/a&gt; and the direction of these patterns based on our 
existing experiences at Google and Hailo.&lt;/p&gt;

&lt;p&gt;Since then though we’ve seen the emergence of gRPC, the dominance of kubernetes and many more systems including 
the service mesh wave. Micro has stood through this test of time and actually thrived as it remained &lt;strong&gt;developer 
first focused&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;To us all these tools are merely implementation details. What really matters is the abstractions and opinions 
provided to the developer and this is why developers continue to adopt Micro in waves.&lt;/p&gt;

&lt;p&gt;We are never the early adopters of these new technologies but when a standard emerges we’re fully onboard with 
committing to a certain direction. In this case we’ve picked gRPC for synchronous communication and NATS for 
async messaging.&lt;/p&gt;

&lt;h2 id=&quot;road-ahead&quot;&gt;Road Ahead&lt;/h2&gt;

&lt;p&gt;Micro started as a solo effort in 2015 as many of you have probably heard numerous times before but we’re now slowly growing a 
group of maintainers and a full time team to build out the next generation of tools and a platform to go beyond 
open source.&lt;/p&gt;

&lt;p&gt;Micro wil be the defacto standard for microservices development in the Cloud and beyond as we look to build a serverless 
platform so developers can focus on what really matters and stop thinking about the underlying infrastructure.&lt;/p&gt;

&lt;p&gt;Join our #platform channel on &lt;a href=&quot;https://micro.mu/community&quot;&gt;Slack&lt;/a&gt; to be the first to try it out.&lt;/p&gt;

&lt;center&gt;...&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
Micro is the simplest way to build microservices. If you’re thinking about microservice development we want to help enable you on that journey. 
To learn more check out the &lt;a href=&quot;https://micro.mu&quot;&gt;website&lt;/a&gt;, follow us on &lt;a href=&quot;https://twitter.com/microhq&quot;&gt;twitter&lt;/a&gt; or 
join the &lt;a href=&quot;https://micro-services.slack.com&quot;&gt;slack&lt;/a&gt; community.&lt;/p&gt;

&lt;h6&gt;&lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt; Micro&lt;/a&gt;&lt;/h6&gt;
</description>
        <pubDate>Thu, 30 Jan 2020 09:00:00 +0000</pubDate>
        <link>https://micro.mu//blog/2020/01/30/micro-v2.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2020/01/30/micro-v2.html</guid>
        
        
      </item>
    
      <item>
        <title>Building a global services network using Go, QUIC and Micro</title>
        <description>&lt;p&gt;Over the past 6 months we at &lt;a href=&quot;https://micro.mu/&quot;&gt;Micro&lt;/a&gt; have been hard at work developing a global service network to build, share and collaborate on microservices.&lt;/p&gt;

&lt;p&gt;In this post we’re going to share some of the technical details, the design decisions we made, challenges we faced and ultimately how we have succeeded in building the microservices network.&lt;/p&gt;

&lt;h2 id=&quot;motivations&quot;&gt;Motivations&lt;/h2&gt;

&lt;p&gt;The power of collaborative development has largely been restricted to trusted environments within organisations. When done right, these private in-house platforms unlock incredible productivity and compounding value with every new service added.They provide an always-on runtime and known developer workflow for engineers to collaborate on and deliver new features to their customers.&lt;/p&gt;

&lt;p&gt;Historically, this has been quite difficult to achieve outside of organisations. When developers decide to work on new services they often have to deal with a lot of unnecessary work when it comes to making the services available to others to consume and collaborate on. Public cloud providers are too complex and the elaborate setups when hosting things yourself don’t make things easier either. At &lt;a href=&quot;https://micro.mu/&quot;&gt;Micro&lt;/a&gt; we felt this pain and decided to do something about it. We built a microservices network!&lt;/p&gt;

&lt;p&gt;The micro network looks to solve these problems using a shared global network for micro services. Let’s see how we’ve made this dream a reality!&lt;/p&gt;

&lt;h2 id=&quot;design&quot;&gt;Design&lt;/h2&gt;

&lt;p&gt;The micro network is a globally distributed network based on &lt;a href=&quot;https://go-micro.dev&quot;&gt;go-micro&lt;/a&gt;, a Go microservices framework which enables developers to build services quickly without dealing with the complexity of distributed systems. Go Micro provides strongly opinionated interfaces that are pluggable but also come with sane defaults. This allows Go Micro services to be built once and deployed anywhere, with zero code changes.&lt;/p&gt;

&lt;p&gt;The micro network leverages five of the core primitives: registry, transport, broker, client and server. Our default implementations can be found in each package in the &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;go-micro&lt;/a&gt; framework. Community maintained plugins live in the &lt;a href=&quot;https://github.com/micro/go-plugins&quot;&gt;go-plugins&lt;/a&gt; repo.&lt;/p&gt;

&lt;p&gt;The micro “network” is an overloaded term, referring both to the global network over which services discover and communicate with each other and the underpinning system consisting of peer nodes whom connect to each and establish the routes over which services communicate.&lt;/p&gt;

&lt;p&gt;The network abstracts away the low level details of distributed system communication at large scale, across any cloud or machine, and allows anyone to build services together without thinking about where they are running. This essentially enables large scale sharing of resources and more importantly microservices.&lt;/p&gt;

&lt;p&gt;There are four fundamental concepts that make the micro network possible. These are entirely new and built into &lt;a href=&quot;https://go-micro.dev/&quot;&gt;Go Micro&lt;/a&gt; as of the last 6 months:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Tunnel&lt;/strong&gt; - point to point tunnelling&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Proxy&lt;/strong&gt; - transparent rpc proxying&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Router&lt;/strong&gt; - route aggregation and advertising&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Network&lt;/strong&gt; - multi-cloud networking built on the above three&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of these components is just like any other &lt;a href=&quot;https://go-micro.dev/&quot;&gt;Go Micro&lt;/a&gt; component - pluggable, with an out of the box default implementation to get started. In our case the micro network it was important that the defaults worked at scale across the world.&lt;/p&gt;

&lt;p&gt;Let’s dig into the details.&lt;/p&gt;

&lt;h3 id=&quot;tunnel&quot;&gt;Tunnel&lt;/h3&gt;

&lt;p&gt;From a high level view the micro network is an overlay network that spans the internet. All micro network nodes maintain secure tunnel connections between each other to enable the secure communication between the services running in the network. Go Micro provides a default tunnel implementation using the QUIC protocol along with custom session management.&lt;/p&gt;

&lt;p&gt;We chose QUIC because it provides some excellent properties especially when it comes to dealing with high latency networks, an important property when dealing with &lt;a href=&quot;https://eng.uber.com/employing-quic-protocol/&quot;&gt;running services in large distributed networks&lt;/a&gt;. QUIC runs over UDP, but by adding some connection based semantics it supports reliable packet delivery. QUIC also supports multiple streams without &lt;a href=&quot;https://en.wikipedia.org/wiki/Head-of-line_blocking&quot;&gt;head of line blocking&lt;/a&gt; and it’s designed to work with encryption natively. Finally, QUIC runs in userspace, not in the kernel space on conventional systems, so it can provide both a performance and extra security, too.&lt;/p&gt;

&lt;p&gt;Micro tunnel uses &lt;a href=&quot;https://github.com/lucas-clemente/quic-go&quot;&gt;quic-go&lt;/a&gt; which is the most complete Go implementation of QUIC that we could find at the inception of the micro network. We are aware quic-go is a work in progress and that it can occasionally break, but we are happy to pay the early adopter cost as we believe QUIC will become the defacto standard internet communication protocol in the future, enabling large scale networks such as the micro network.&lt;/p&gt;

&lt;p&gt;Let’s look at the Go Micro tunnel interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Tunnel creates a gre tunnel on top of the go-micro/transport.
// It establishes multiple streams using the Micro-Tunnel-Channel header
// and Micro-Tunnel-Session header. The tunnel id is a hash of
// the address being requested.
type Tunnel interface {
	// Address the tunnel is listening on
	Address() string
	// Connect connects the tunnel
	Connect() error
	// Close closes the tunnel
	Close() error
	// Links returns all the links the tunnel is connected to
	Links() []Link
	// Dial to a tunnel channel
	Dial(channel string, opts ...DialOption) (Session, error)
	// Accept connections on a channel
	Listen(channel string, opts ...ListenOption) (Listener, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It may look fairly familiar to Go developers. With Go Micro we’ve tried to maintain common interfaces in line with distributed systems development while stepping in at a lower layer to solve some of the nitty gritty details.&lt;/p&gt;

&lt;p&gt;Most of the interface methods should hopefully be self-explanatory, but you might be wondering about channels and sessions. Channels are much like addresses, providing a way to segment different message streams over the tunnel. Listeners listen on a given channel and return a unique session when a client dials into the channel. The session is used to communicate between peers on the same tunnel channel. The Go Micro tunnel provides different communication semantics too. You can choose to use either unicast or multicast.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://micro.mu/docs/images/session.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In addition tunnels enable bidirectional connections; sessions can be dialled or listened from either side. This enables the reversal of connections so anything behind a &lt;a href=&quot;https://en.wikipedia.org/wiki/Network_address_translation&quot;&gt;NAT&lt;/a&gt; or without a public IP can become a server.&lt;/p&gt;

&lt;h3 id=&quot;router&quot;&gt;Router&lt;/h3&gt;

&lt;p&gt;Micro router is a critical component of the micro network. It provides the network’s routing plane. Without the router, we wouldn’t know where to send messages. It constructs a routing table based on the local service registry (a component of Go Micro). The routing table maintains the routes to the services available on the local network. With the tunnel its then also able to process messages from any other datacenter or network enabling global routing by default.&lt;/p&gt;

&lt;p&gt;Our default routing table implementation uses a simple Go in memory map, but as with all things in Go Micro, the router and routing table are both pluggable. As we scale we’re thinking about alternative implementations and even the possibility of switching dynamically based on the size of networks.&lt;/p&gt;

&lt;p&gt;The Go Micro router interface is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Router is an interface for a routing control plane
type Router interface {
	// The routing table
	Table() Table
	// Advertise advertises routes to the network
	Advertise() (&amp;lt;-chan *Advert, error)
	// Process processes incoming adverts
	Process(*Advert) error
	// Solicit advertises the whole routing table to the network
	Solicit() error
	// Lookup queries routes in the routing table
	Lookup(...QueryOption) ([]Route, error)
	// Watch returns a watcher which tracks updates to the routing table
	Watch(opts ...WatchOption) (Watcher, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the router starts it automatically creates a watcher for its local registry. The micro registry emits events any time services are created, updated or deleted. The router processes these events and then applies actions to its routing table accordingly. The router itself advertises the routing table events which you can think of as a cut down version of the registry solely concerned with routing of requests where as the registry provides more feature rich information like api endpoints.&lt;/p&gt;

&lt;p&gt;These routes are propagated as events to other routers on both the local and global network and applied by every router to their own routing table. Thus maintaining the global network routing plane.&lt;/p&gt;

&lt;p&gt;Here’s a look at a typical route:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Route is a network route
type Route struct {
	// Service is destination service name
	Service string
	// Address is service node address
	Address string
	// Gateway is route gateway
	Gateway string
	// Network is the network name
	Network string
	// Router is router id
	Router string
	// Link is networks link
	Link string
	// Metric is the route cost
	Metric int64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we’re primarily concerned with here is routing by service name first, finding its address if its local or a gateway if we have to go through some remote endpoint or different network. We also want to know what type of Link to use e.g whether routing through our tunnel, Cloudflare Argo tunnel or some other network implementation. And then most importantly the metric a.k.a. the cost of routing to that node. We may have many routes and we want to take routes with optimal cost to ensure lowest latency. This doesn’t always mean your request is sent to the local network though! Imagine a situation when the service running on your local network is overloaded. We will always pick the route with the lowest cost no matter where the service is running.&lt;/p&gt;

&lt;h3 id=&quot;proxy&quot;&gt;Proxy&lt;/h3&gt;

&lt;p&gt;We’ve already discussed the tunnel - how messages get from point to point, and routing - detailing how to find where the services are, but then the question really is how do services actually make use of this? For this we really need a proxy.&lt;/p&gt;

&lt;p&gt;It was important to us when building the micro network that we build something that was native to micro and capable of understanding our routing protocol. Building another VPN or IP based networking solution was not our goal. Instead we wanted to facilitate communication between services.&lt;/p&gt;

&lt;p&gt;When a service needs to communicate with other services in the network it uses micro proxy.&lt;/p&gt;

&lt;p&gt;The proxy is a native RPC proxy implementation built on the Go Micro &lt;code&gt;Client&lt;/code&gt; and &lt;code&gt;Server&lt;/code&gt; interfaces. It encapsulates the core means of communication for our services and provides a forwarding mechanism for requests based on service name and endpoints. Additionally it has the ability to also act as a messaging exchange for asynchronous communication since Go Micro supports both request/response and pub/sub communication. This is native to Go Micro and a powerful building block for request routing.&lt;/p&gt;

&lt;p&gt;The interface itself is straightforward and encapsulates the complexity of proxying.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Proxy can be used as a proxy server for go-micro services
type Proxy interface {
	// ProcessMessage handles inbound messages
	ProcessMessage(context.Context, server.Message) error
	// ServeRequest handles inbound requests
	ServeRequest(context.Context, server.Request, server.Response) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The proxy receives RPC requests and routes them to an endpoint. It asks the router for the location of the service (caching as needed) and decides based on the &lt;code&gt;Link&lt;/code&gt; field in the routing table whether to send the request locally or over the tunnel across the global network. The value of the &lt;code&gt;Link&lt;/code&gt; field is either &lt;code&gt;“local&quot;&lt;/code&gt; (for local services) or &lt;code&gt;“network&quot;&lt;/code&gt; if the service is accessible only via the network.&lt;/p&gt;

&lt;p&gt;Like everything else, the proxy is something we built standalone that can work between services in one datacenter but also across many when used in conjunction with the tunnel and router.&lt;/p&gt;

&lt;p&gt;And finally arriving at the pièce de résistance. The network interface.&lt;/p&gt;

&lt;h3 id=&quot;network&quot;&gt;Network&lt;/h3&gt;

&lt;p&gt;Network nodes are the magic that ties all the core components together. Enabling the ability to build a truly global service network. It was really important when creating the network interface that it fit inline with our existing assumptions and understanding about Go Micro and distributed systems development. We really wanted to embrace the existing interfaces of the framework and design something with symmetry in regards to a Service.&lt;/p&gt;

&lt;p&gt;What we arrived at was something very similar to the &lt;a href=&quot;https://github.com/micro/go-micro/blob/master/micro.go#L16&quot;&gt;micro.Service&lt;/a&gt; interface itself&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Network is a micro network
type Network interface {
	// Node is network node
	Node
	// Name of the network
	Name() string
	// Connect starts the resolver and tunnel server
	Connect() error
	// Close stops the tunnel and resolving
	Close() error
	// Client is micro client
	Client() client.Client
	// Server is micro server
	Server() server.Server
}

// Node is a network node
type Node interface {
	// Id is node id
	Id() string
	// Address is node bind address
	Address() string
	// Peers returns node peers
	Peers() []Node
	// Network is the network node is in
	Network() Network
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, a &lt;code&gt;Network&lt;/code&gt; has a Name, Client and Server, much like a &lt;code&gt;Service&lt;/code&gt;, so it provides a similar method of communication. This means we can reuse a lot of the existing code base, but it also goes much further. A &lt;code&gt;Network&lt;/code&gt; includes the concept of a &lt;code&gt;Node&lt;/code&gt; directly in the interface, one which has peers and whom may belong to the same network or others. This means is networks are peer-to-peer while Services are largely focused on Client/Server. On a day to day basis developers stay focused on building services but these when built to communicate globally need to operate across networks made up of identical peers.&lt;/p&gt;

&lt;p&gt;Our networks have the ability to behave as peers which route for others but also may provide some sort of service themselves. In this case it’s mostly routing related information.&lt;/p&gt;

&lt;p&gt;So how does it all work together?&lt;/p&gt;

&lt;p&gt;Networks have a list of peer nodes to talk to. In the case of the default implementation the peer list comes from the registry with other network nodes with the same name (the name of the network itself). When a node starts it “connects” to the network by establishing its tunnel, resolving the nodes and then connecting to them. Once they’ve connected the nodes peer over two multicast sessions, one for peer announcements and the other for route advertisements. As these propagate the network begins to converge on identical routing information building a full mesh that allows for routing of services from any node to the other.&lt;/p&gt;

&lt;p&gt;The nodes maintain keepalives, periodically advertise the full routing table and flush any events as they occur. Our core network nodes make use of multiple resolvers to find each other, including DNS and the local registry. In the case of peers that join our network, we’ve configured them to use a http resolver which gets geo-steered via Cloudflare anycast DNS and global load balanced to the most local region. From there they pull a list of nodes and connect to the ones with the lowest metric. They then repeat the same song and dance as above to continue the growth of the network and participate in service routing.&lt;/p&gt;

&lt;p&gt;Each node maintains its own network graph based on the peer messages it receives. Peer messages contain the graph of each peer up to 3 hops which enables the ability for every node to build a local view of the network. Peers ignore anything with more than a 3 hop radius. This is to avoid potential performance problems.&lt;/p&gt;

&lt;p&gt;We mentioned a little something about peer and route advertisements. So what message do the network nodes actually exchange? First, the network embeds the router interface through which it advertises its local routes to other network nodes. These routes are then propagated across the whole network, much like the internet. The node itself receives route advertisements from its peers and applies the advertised changes to its routing own routing table. The message types are “solicit” to ask for routes and “advert” for updates broadcast.&lt;/p&gt;

&lt;p&gt;Network nodes send “connect” messages on start and “close” on exit. For their lifetime they are periodically broadcasting “peer” messages so that others can discover them and they all can build the network topology.&lt;/p&gt;

&lt;p&gt;When the network is created and converges, services are then capable of sending messages across it. When a service on the network needs to communicate with some other service on the network it sends a request to the network node. The micro network node embeds micro proxy and thus has the ability to forward the request through network or locally if it deems so more fit based on the metrics it retrieves after looking up the routes in the routing table.&lt;/p&gt;

&lt;p&gt;This as a whole forms our micro services network.&lt;/p&gt;

&lt;h2 id=&quot;challenges&quot;&gt;Challenges&lt;/h2&gt;

&lt;p&gt;Building a global services is not without its challenges. We encountered many from the initial design phase right through to the present day of dealing with broken nodes, bad actors, event storms and more.&lt;/p&gt;

&lt;h3 id=&quot;initial-implementation&quot;&gt;Initial Implementation&lt;/h3&gt;

&lt;p&gt;The actual task we’d set out to accomplish was pretty monumental and we’d underestimated how much effort it would take even in an MVP phase of the first implementation.&lt;/p&gt;

&lt;p&gt;Every time we attempted to go from design diagram to implementing code we found ourselves stuck. In theory everything made sense but no matter how many times we attempted to write code things just didn’t click.&lt;/p&gt;

&lt;p&gt;We wrote 3-4 implementations that were essentially thrown away before figuring out the best approach was to make local networking work first and then slowly carve out specific problems to solve. So proxying, following by routing and then a network interface. Eventually when these pieces were in place we could get to multi-cloud or global networking by implementing a tunnel to handle the heavy lifting.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;https://micro.mu/images/it-works.jpg&quot; style=&quot;width: 80%; height: auto;&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;Once again, the lesson is to keep it simple, but where the task itself is complex, break it down into steps you can actually keep simple independently and then piece back together in practice.&lt;/p&gt;

&lt;h3 id=&quot;multipoint-tunneling&quot;&gt;Multipoint Tunneling&lt;/h3&gt;

&lt;p&gt;One of the most complex pieces of code we had to write was the tunnel. It’s still not where we’d like it to be but it was pretty important to us to write this from the ground up so we’d have a good understanding of how we wanted to operate globally but also have full control over the foundations of the system.&lt;/p&gt;

&lt;p&gt;The complexity in writing network protocols really came to light in this effort, from trying to NOT reimplement tcp, crypto or anything else but also find a path to a working solution. In the end we were able to create a subset of commands which formed enough of a bidirectional and multi-session based tunnel over QUIC. We left most of the heavy lifting to QUIC but we also needed the ability to do multicast.&lt;/p&gt;

&lt;p&gt;For us it didn’t make sense to just rely on unicast, considering the async and pubsub based semantics built into Go Micro we felt pretty adamant it needed to be part of core network routing. So with that sessions needed to be reimplemented on top of QUIC.&lt;/p&gt;

&lt;p&gt;We’ll spare you the gory details but what’s really clear to us is that writing state machines and reliable connection protocol code is not where we want to spend the majority of our time. We have a fairly resilient working solution but our hope is to replace this with something far better in the future.&lt;/p&gt;

&lt;h3 id=&quot;event-storms&quot;&gt;Event Storms&lt;/h3&gt;

&lt;p&gt;When things work they work and when they break they break badly. For us everything came crashing down when we started to encounter broadcast storms caused by services being recycled. When a service is created the service registry fires a create event and when it’s shutting down it automatically deregisters from service registry which fires a delete event. Maybe you can see where this is going. As services cycled in our network they’d generate these events which leads to the routers generating new route events which are then propagated every 5 seconds to every other node on the network.&lt;/p&gt;

&lt;p&gt;This sounds ok if the network converges and they stop propagating events but in our case the sequence of events are observed and applied at random time intervals on every node. This in essence can lead to a broadcast storm which never stops. Understanding and resolving this is an incredibly difficult task.&lt;/p&gt;

&lt;p&gt;For us this really led to research in BGP internet routing in which they’ve defined flap detection algorithms to handle this. We’ve read a few whitepapers to get familiar with the concepts and hacked up a simple flap detection algorithm in the router.&lt;/p&gt;

&lt;p&gt;At its core, the flap detection assigns a numerical cost to every route event. When a route event occurs it’s cost gets incremented. If the same event happens multiple times within a certain period of time and the accumulated cost reaches a predefined threshold the event is immediately suppressed. Suppressed events are not processed by router, but are kept in a memory cache for a redefined period of time. Meanwhile the cost of the event decays with time whilst at the same time it can keep on growing if the event keeps on flapping. If the event drops below another threshold the event is unsuppressed and can be processed by the routers. If the event remains suppressed for longer than a predefined time period it’s discarded.&lt;/p&gt;

&lt;p&gt;The picture below depicts how the decaying actually works.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;https://micro.mu/blog/assets/images/flap-detection.png&quot; style=&quot;width: 80%; height: auto;&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;small&gt;source: http://linuxczar.net/blog/2016/01/31/flap-detection/&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;This had a huge effect on the issues we had been experiencing in the network. The nodes were no longer hammered with crazy event storms and the network stabilised and continued to work without any interruptions. Happy days!&lt;/p&gt;

&lt;h2 id=&quot;architecture&quot;&gt;Architecture&lt;/h2&gt;

&lt;p&gt;Our overall goal is to build a micro services network that manages not only communication but all aspects of running services, governance, and more. To accomplish this we started by addressing networking from the ground up for Go Micro services. Not just to communicate locally within one private network but to have the ability to do so across many networks.&lt;/p&gt;

&lt;p&gt;For this purpose we’ve created a global multi-cloud network that enables communication from anywhere, with anyone. This is fundamental to the architecture of the micro services network.&lt;/p&gt;

&lt;p&gt;Our next goal will be to tackle the runtime aspects so that we offer the ability to host services without the need to manage them. This could be imagined as the basis of a serverless microservices platform which we’re looking to launch soon.&lt;/p&gt;

&lt;p&gt;The platform is designed to be open. Anyone should be able to run services on the platform or join the global network using their own node. What’s more, you can even pick up the open source code and build their own private networks or join theirs to our public one.&lt;/p&gt;

&lt;center&gt;
  &lt;img src=&quot;https://github.com/micro/development/raw/f4c77580acac228c522623c217575fb266d2d4ab/images/arch.jpg&quot; style=&quot;width: 80%; height: auto;&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;What we think is pretty cool and rather unique about the micro network is the network nodes themselves are just regular micro services like any other. Because we built everything using Go Micro they behave just like any other service. In fact what’s even more exciting is that literally &lt;em&gt;everything is a service&lt;/em&gt; in the micro network.&lt;/p&gt;

&lt;p&gt;This holds true for all the individual components that make up the network. If you don’t want to run full network nodes, you can also run individual components of the network separately as standalone micro services such as the tunnel, router and proxy. All the components register themselves with local registry via which they can be discovered.&lt;/p&gt;

&lt;h2 id=&quot;eventual-success&quot;&gt;Eventual success&lt;/h2&gt;

&lt;p&gt;On 29th August 2019 around 4PM we sent the first successful RPC request between our laptops across the internet using the micro network.&lt;/p&gt;

&lt;center&gt;
  &lt;img src=&quot;https://micro.mu/blog/assets/images/success.jpg&quot; style=&quot;width: 80%; height: auto;&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Since then we have squashed a lot of bugs and deployed the network nodes across the globe.
At the moment we are running the micro network in 4 cloud providers across 4 geographical regions with 3 nodes in each region.&lt;/p&gt;

&lt;center&gt;
  &lt;img src=&quot;https://micro.mu/blog/assets/images/radar.png&quot; style=&quot;width: 80%; height: auto;&quot; /&gt;
&lt;/center&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;If you’re interested in testing out micro and the network just do the following.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;# enable go modules
export GO111MODULE=on

# download micro
go get github.com/micro/micro@master

# connect to the network
micro --peer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you’re connected to the network. Start to explore what’s there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;# List the services in the network
micro network services

# See which nodes you're connected to
micro network connections

# List all the nodes in your network graph
micro network nodes

# See what the metrics look like to different service routes
micro network routes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what does a micro network developer workflow look like? Developers write their Go code using the &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;Go Micro&lt;/a&gt; framework and once they’re ready they can make their services available on the network either directly from their laptop or from anywhere the micro network node runs (more on what micro network node is later).&lt;/p&gt;

&lt;p&gt;Here is an example of a simple service written using &lt;code&gt;go-micro&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;context&quot;
	&quot;log&quot;
	&quot;time&quot;

	hello &quot;github.com/micro/examples/greeter/srv/proto/hello&quot;
	&quot;github.com/micro/go-micro&quot;
)

type Say struct{}

func (s *Say) Hello(ctx context.Context, req *hello.Request, rsp *hello.Response) error {
	log.Print(&quot;Received Say.Hello request&quot;)
	rsp.Msg = &quot;Hello &quot; + req.Name
	return nil
}

func main() {
	service := micro.NewService(
		micro.Name(&quot;helloworld&quot;),
	)

	// optionally setup command line usage
	service.Init()

	// Register Handlers
	hello.RegisterSayHandler(service.Server(), new(Say))

	// Run server
	if err := service.Run(); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you launch the service it automatically registers with service registry and becomes instantly accessible to everyone on the network to consume and collaborate on. All of this is completely transparent to developers. No need to deal with low level distributed systems cruft!&lt;/p&gt;

&lt;p&gt;We’re already running a greeter service in the network so why not try giving it a call.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# enable proxying through the network
export MICRO_PROXY=go.micro.network

# call a service
micro call go.micro.srv.greeter Say.Hello '{&quot;name&quot;: &quot;John&quot;}'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Building distributed systems is difficult, but it turns out building the networks they communicate over is an equally, if not more difficult, problem. The classic fallacy, &lt;a href=&quot;https://queue.acm.org/detail.cfm?id=2655736&quot;&gt;the network is reliable&lt;/a&gt;, continues to hold, as we found while building the micro network. However what’s also clear is that our world and most technology thrives through the use of networks. They underpin the very fabric of all that we’ve come to know. Our goal with the micro network is to create a new type of foundation for the open services of the future. Hopefully this post shed some light on the technical accomplishments and challenges of building such a thing.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
To learn more check out the &lt;a href=&quot;https://micro.mu&quot;&gt;website&lt;/a&gt;, follow us on &lt;a href=&quot;https://twitter.com/microhq&quot;&gt;twitter&lt;/a&gt; or 
join the &lt;a href=&quot;https://micro.mu/slack&quot;&gt;slack&lt;/a&gt; community. We are hiring!&lt;/p&gt;

</description>
        <pubDate>Thu, 05 Dec 2019 09:00:00 +0000</pubDate>
        <link>https://micro.mu//blog/2019/12/05/building-a-microservices-network.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2019/12/05/building-a-microservices-network.html</guid>
        
        
      </item>
    
      <item>
        <title>What is Micro? It's just the future of microservices development.</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;strong&gt;Micro&lt;/strong&gt;&lt;/a&gt; is an open source project focused on simplifying microservices development. 
It started life as &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;&lt;strong&gt;go-micro&lt;/strong&gt;&lt;/a&gt; - a Go framework for microservice development. But even 
before then, go-micro, was a hacked up tiny library created to enable the development of a “kubernetes as a service” 
project way back when in 2014 (see the first commit &lt;a href=&quot;https://gist.github.com/asim/a035820aec2d8cba5d73b5be12c6e707&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Go Micro&lt;/strong&gt; was an idea born out of that attempt to build kubernetes as a service, which was written as a set of microservices, 
but ultimately was too early and scrapped not long after being built. What was left behind though was the kernel of 
something else, a handful of packages which if you squinted hard enough looked like the basis for a framework.&lt;/p&gt;

&lt;h1 id=&quot;2014-in-the-beginning&quot;&gt;2014: In the beginning&lt;/h1&gt;

&lt;p&gt;At the time microservices was a hot topic but tooling was sparse. People spoke of the benefits of this form 
of architecture and development at their organisations but nobody really had the opportunity to open source their tools 
including our team at Hailo.&lt;/p&gt;

&lt;p&gt;I had noticed a pattern back then. A developer joined a company for a couple years, helped build a platform 
and set of services for the business, only to leave and then have to go do it all over again at the next company, 
with no ability to carry over the tools of the first. This really frustrated me. Especially 
because if the right tools existed as open source software we wouldn’t have to continually go through this process 
and perhaps we’d be focusing on more interesting problems. Not to mention we’d probably save 6-9 months of our lives 
at the very least.&lt;/p&gt;

&lt;p&gt;This started to get me thinking about a way for many companies to rally around a single solution. I knew 
a few things though. Every organisation had different skills, different infrastructure preferences and 
adopting new tools was often a big hurdle.&lt;/p&gt;

&lt;p&gt;With that in mind my idea was to start with a very lightweight yet opinionated framework for microservices development. 
Knowing how this approach had benefited us at Hailo it felt like it might resonate with other developers too. So over 
the next couple of months I started to work on what eventually formed the initial go-micro framework.&lt;/p&gt;

&lt;h1 id=&quot;2015-open-sourcing-go-micro&quot;&gt;2015: Open sourcing go-micro&lt;/h1&gt;

&lt;p&gt;In early 2015 I decided to open source go-micro. I was deathly afraid of the idea considering I’d never really 
actively publicised a project before and was worried about the 
quality of my code but there wasn’t much to lose really. Go Micro felt like something worth sharing.&lt;/p&gt;

&lt;p&gt;As with a lot of open source projects, I posted to &lt;a href=&quot;https://news.ycombinator.com/item?id=8895794&quot;&gt;Hacker News&lt;/a&gt;. 
It didn’t really get any comments, I can’t even remember if it 
was on the front page but what I do remember is hitting 300 stars within a few days!&lt;/p&gt;

&lt;p&gt;I don’t have a quick view of the earliest release on github but thankfully Brian Ketelsen, a good friend and strong 
advocate of Micro forked it back then. You can see that code at &lt;a href=&quot;https://github.com/bketelsen/go-micro&quot;&gt;github.com/bketelsen/go-micro&lt;/a&gt; and from it it’s clear there was a few packages outlining a method of microservices communication.&lt;/p&gt;

&lt;center&gt;
&lt;a href=&quot;https://github.com/bketelsen/go-micro&quot;&gt;
  &lt;img src=&quot;/blog/assets/images/fork.png&quot; style=&quot;height: auto; width: 80%; margin: 0&quot; /&gt;
&lt;/a&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
Go Micro at the time included a &lt;strong&gt;registry&lt;/strong&gt; for service discovery, &lt;strong&gt;server&lt;/strong&gt; for RPC and protobuf based request 
handling and a &lt;strong&gt;client&lt;/strong&gt; to call those services by name. It even included a key-value storage package but 
we later removed this to focus entirely on communication first (we’ve recently added it back in).&lt;/p&gt;

&lt;h1 id=&quot;micro-a-microservices-toolkit&quot;&gt;Micro: A microservices toolkit&lt;/h1&gt;

&lt;p&gt;Somewhere in mid-2015 I came to the realisation that a framework was not enough. Once you’d written those services 
there needed to be a way to access them, to serve them, and to consume them by traditional means. This is where 
I began to think about a toolkit.&lt;/p&gt;

&lt;p&gt;In a lot of cases we see open source tools which try to solve one problem. State, load balancing, messaging, etc but 
in the case of microservices you really needed a holistic system that would cover all the bases in a seamless way. 
Something that would essentially form the foundations of a platform.&lt;/p&gt;

&lt;p&gt;In that &lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;strong&gt;Micro&lt;/strong&gt;&lt;/a&gt; was born. Micro was built as a toolkit to enable the development of 
a microservices platform. It contained a CLI, Web dashboard and API gateway along with a sidecar for non Go based 
applications. That sidecar pattern has now evolved into something called “service mesh” but back then Netflix 
had this thing called &lt;a href=&quot;https://github.com/Netflix/Prana&quot;&gt;Prana&lt;/a&gt; which is what the Micro sidecar was based on.&lt;/p&gt;

&lt;p&gt;Micro and Go Micro were my full focus for the rest of 2015 and took a significant period of time to develop but 
in Autumn of that year a few companies started to use it in production which gave me hope that it may thrive 
in the years to come.&lt;/p&gt;

&lt;h1 id=&quot;2016-validating-the-tooling&quot;&gt;2016: Validating the tooling&lt;/h1&gt;

&lt;p&gt;In 2016 I decided it was time to test the waters once more. To let the world know about Micro and drum up some traction.
I went to Hacker News once more, only this time, things went a bit differently 
&lt;a href=&quot;https://news.ycombinator.com/item?id=11327679&quot;&gt;https://news.ycombinator.com/item?id=11327679&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hacker News responded positively and Micro shot to the top of the front page. Here’s the original blog post 
for those interested in reading it &lt;a href=&quot;https://micro.mu/blog/2016/03/20/micro.html&quot;&gt;https://micro.mu/blog/2016/03/20/micro.html&lt;/a&gt;.&lt;/p&gt;

&lt;center&gt;
&lt;a href=&quot;https://micro.mu/blog/2016/03/20/micro.html&quot;&gt;
  &lt;img src=&quot;/blog/assets/images/micro-post.png&quot; style=&quot;height: auto; width: 80%; margin: 0&quot; /&gt;
&lt;/a&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;It was clear there was something here, that there might be a demand for such a set of tools, and I wanted to pursue 
it full time. Back then I got the opportunity to work with &lt;a href=&quot;sixt.com&quot;&gt;Sixt&lt;/a&gt; through a corporate sponsorship. This 
allowed me to work full time on Micro and use them as a feedback loop for it’s features and development.&lt;/p&gt;

&lt;p&gt;I’m incredibly grateful to Sixt for that opportunity and what it allowed Micro to become. Without them it’s unclear 
if it would have made it to where it is today. The sponsorship let me continue to iterate on the tools 
as a solo effort for a few years. 3 years in fact.&lt;/p&gt;

&lt;p&gt;And in that time, Micro grew, from a small open source project, to one with a community of 1k+ members, thousands 
of GitHub stars, but more importantly use in the real world in production.&lt;/p&gt;

&lt;h1 id=&quot;2019-the-evolution-of-micro&quot;&gt;2019: The evolution of Micro&lt;/h1&gt;

&lt;p&gt;Fast forward to the present. Earlier this year I got the opportunity to take Micro from a solo bootstrapped open source 
project and turn it into a venture funded company with the potential to change microservices development on a much larger scale.&lt;/p&gt;

&lt;p&gt;We’re not ready to reveal all the details just yet but what I will say is it’s enabled us to start executing on what many of 
us developers long for. The ability to build, share and collaborate on services in the cloud and beyond, without the 
hassle of managing infrastructure.&lt;/p&gt;

&lt;h2 id=&quot;progress&quot;&gt;Progress&lt;/h2&gt;

&lt;p&gt;The progress we’ve made as a small team in 6 months is pretty astounding. Having committed more times in that period than I had 
done in the entire 4 years of working on Micro alone.&lt;/p&gt;

&lt;center&gt;
  &lt;img src=&quot;/blog/assets/images/commits.png&quot; style=&quot;height: auto; width: 80%; margin: 0&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;And as you can see here, if GitHub stars are a measure of anything, it reflects in our awareness, popularity and usage. 
We recently passed the 10k star mark on the &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;go-micro&lt;/a&gt; framework and it feels as though we’re 
just getting started with what’s possible.&lt;/p&gt;

&lt;center&gt;
  &lt;img src=&quot;/blog/assets/images/10k-stars.png&quot; style=&quot;height: auto; width: 80%; margin: 0&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;You can probably tell exactly where we went from 1 person to 2. Based on this progress I’m fairly confident in my previous assumption 
that &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;go-micro&lt;/a&gt; will go on to become the most dominant Go framework and likely surpass Spring 
adoption globally within the next decade.&lt;/p&gt;

&lt;h2 id=&quot;micro-as-a-runtime&quot;&gt;Micro as a Runtime&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/micro/micro&quot;&gt;Micro&lt;/a&gt; has also progressed significantly as we’ve moved on from just a sparse set of tools to 
something we’re now calling &lt;strong&gt;a microservice runtime environment&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The idea behind this is to reorient the toolkit to be a full fledged 
environment for building microservices. One which provides a programmable abstraction layer for the underlying infrastructure built 
as microservices themselves.&lt;/p&gt;

&lt;p&gt;This image is a little old but you’ll get the idea. By abstracting away the underlying infrastructure and creating it as a set of 
services that all look the same, run the same, feel the same we end up with a programmable runtime that acts as a foundation for 
all development, whether it be local, in docker or on kubernetes in the cloud.&lt;/p&gt;

&lt;center&gt;
  &lt;img src=&quot;/blog/assets/images/runtime.png&quot; style=&quot;height: auto; width: 80%; margin: 0&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
We also redefine the boundaries between development and operations in a way that allows each side to focus on their roles without 
the cognitive load of understanding the other side. In the developers case, we no longer have to reason about infrastructure just code.&lt;/p&gt;

&lt;p&gt;The feature set is fairly extensive and growing.&lt;/p&gt;

&lt;center&gt;
  &lt;img src=&quot;/blog/assets/images/feature-set.png&quot; style=&quot;height: auto; width: 80%; margin: 0&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;micro-as-a-platform&quot;&gt;Micro as a Platform&lt;/h2&gt;

&lt;p&gt;Even still while Micro as a runtime and having a Go framework for development solves a lot of problems, this isn’t enough. 
So Micro continues to evolve. It’s no longer enough to just simply provide the tools for building microservices, we also need to
provide the environment in which to share and consume them. We at Micro are now building a &lt;strong&gt;global shared microservices platform&lt;/strong&gt; for 
developers by developers.&lt;/p&gt;

&lt;p&gt;What does that really mean? Well imagine the platform you’re given to work on when you join a company or all of the things you 
have to do from an infrastructure perspective just to get up and running. We’re going to provide this as a service to everyone.&lt;/p&gt;

&lt;p&gt;A fully managed serverless platform for microservices development (that’s a mouthful).&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;Why?&lt;/h2&gt;

&lt;p&gt;I’ve become frustrated with the status quo and the way in which developers are now forced to reason about infrastructure 
and cloud-native complexity. The barrier to entry in just getting started is too high. Building services in the cloud 
should be getting vastly easier, not harder.&lt;/p&gt;

&lt;p&gt;Just take a look at the cloud-native landscape…&lt;/p&gt;

&lt;center&gt;
&lt;a href=&quot;https://landscape.cncf.io&quot;&gt;
  &lt;img src=&quot;/blog/assets/images/cncf.png&quot; style=&quot;height: auto; width: 80%; margin: 0&quot; /&gt;
&lt;/a&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Having to reason about this as a developer is horrible. All I want to do is write and ship software but now 
I’m expected to walk some arduous path of containers, container orchestration, docker, kubernetes, service mesh, etc, etc. 
Why can’t I just write code and run it?&lt;/p&gt;

&lt;h2 id=&quot;microservices&quot;&gt;Microservices&lt;/h2&gt;

&lt;p&gt;You’re probably thinking. Ok that’s great, I buy into this vision. Simpler app development without managing infrastructure 
but what’s microservices got to do with this?&lt;/p&gt;

&lt;p&gt;We firmly believe that all forms of development at scale inevitably end up as distributed systems and the pattern 
for that development is now largely known as &lt;strong&gt;microservices&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Microservices unlock a huge productivity boost in the companies that adopt them and the velocity of their 
development is such that with every new service added their is compounding value in the system built.&lt;/p&gt;

&lt;p&gt;I also believe that developers need a platform that enables this form of development for them to thrive. One in which
they do not have to reason about infrastructure and where they are provided the tools that empower them to build software at 
scale without having to worry about operating large scale systems.&lt;/p&gt;

&lt;p&gt;One highly controversial example I want to share is from the startup bank &lt;a href=&quot;https://monzo.com&quot;&gt;Monzo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Monzo opted to pursue a microservices architecture from day 1. Knowing there were initial operational tradeoffs to this 
approach but with an insight from their time at Hailo, they knew if the company succeeded on the product side they’d 
need a scalable platform to help them grow and move fast.&lt;/p&gt;

&lt;p&gt;This led to the creation of a platform that is now host to 1500 services. This might sound hard to reason about, but 
a shared platform where every developer has the ability to consume and reuse existing services is a fundamentally powerful thing.&lt;/p&gt;

&lt;p&gt;Not only that, but when the platform is managed for you, developers can get back to focusing on what’s really important. The 
product and the business.&lt;/p&gt;

&lt;center&gt;
&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;1500 microservices at &lt;a href=&quot;https://twitter.com/monzo?ref_src=twsrc%5Etfw&quot;&gt;@monzo&lt;/a&gt;; every line is an enforced network rule allowing traffic &lt;a href=&quot;https://t.co/2r2y9f6LYO&quot;&gt;pic.twitter.com/2r2y9f6LYO&lt;/a&gt;&lt;/p&gt;&amp;mdash; Jack Kleeman (@JackKleeman) &lt;a href=&quot;https://twitter.com/JackKleeman/status/1190354757308862468?ref_src=twsrc%5Etfw&quot;&gt;November 1, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async=&quot;&quot; src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;our-solution&quot;&gt;Our solution&lt;/h1&gt;

&lt;p&gt;This form of development has largely been siloed at large tech cos capable of building such systems. But what 
if this was available to every developer as a shared system outside of those large orgs. What if we were able to 
collaborate across org and across teams. What would the velocity of our development as an industry look like as a whole?&lt;/p&gt;

&lt;p&gt;I would argue that all technology would advance faster than it ever has done in the decades that have come before us.
We would finally capture the true potential of the internet.&lt;/p&gt;

&lt;p&gt;GitHub was a prime example of this collaboration and innovation in open source, massively reducing the pain of hosting 
source code and creating an environment for reusing code. However there’s just one but, this source code largely sits 
at rest on their platform.&lt;/p&gt;

&lt;p&gt;What if instead of just sharing code and running it in silos, we shared an environment for software development, one 
in which we could collaborate on services, reusing each others running applications where necessary and focusing 
on solving higher order problems.&lt;/p&gt;

&lt;p&gt;It would have it’s own quirks and challenges but the opportunities such a platform presents is immense. And something 
we want to explore at &lt;a href=&quot;https://micro.mu&quot;&gt;Micro&lt;/a&gt;, the company.&lt;/p&gt;

&lt;p&gt;So that’s what we’re setting out to do really. To build a global shared services platform for developers by developers. 
Where the pains of cloud, kubernetes and everything else will no longer be felt. An environment 
in which we can build, share and collaborate on micro services based on the &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;&lt;strong&gt;go-micro&lt;/strong&gt;&lt;/a&gt; framework.&lt;/p&gt;

&lt;h1 id=&quot;closing&quot;&gt;Closing&lt;/h1&gt;

&lt;p&gt;The future of Micro is one which involves rapidly reducing the friction for developers in harnessing the power of 
the cloud and to empower them to build microservices from anywhere, with anyone.&lt;/p&gt;

&lt;p&gt;If this sounds interesting to you, come join our community on &lt;a href=&quot;https://micro.mu/slack&quot;&gt;&lt;strong&gt;slack&lt;/strong&gt;&lt;/a&gt;, kick the tyres 
on the &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;&lt;strong&gt;go-micro&lt;/strong&gt;&lt;/a&gt; framework or come help us make it a reality. We’re hiring, 
just drop us an email at &lt;a href=&quot;mailto:hello@micro.mu&quot;&gt;&lt;b&gt;hello@micro.mu&lt;/b&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Cheers
&lt;br /&gt;
Asim&lt;/p&gt;

&lt;h6&gt;&lt;a href=&quot;https://micro.mu&quot;&gt;Micro&lt;/a&gt;&lt;/h6&gt;
</description>
        <pubDate>Mon, 18 Nov 2019 09:00:00 +0000</pubDate>
        <link>https://micro.mu//blog/2019/11/18/what-is-micro.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2019/11/18/what-is-micro.html</guid>
        
        
      </item>
    
      <item>
        <title>Deprecating Consul in favour of Etcd</title>
        <description>&lt;p&gt;&lt;br /&gt;
For over 4 years Consul has served us well as one of the default service discovery systems in Micro. It was 
in fact in the very beginning the default mechanism used for the registry and the only underlying 
dependency required to get started.&lt;/p&gt;

&lt;p&gt;Since then the world has moved on and cloud-native technologies have evolved. We’ve found a number of issues 
at scale related to the way in which we use Consul. This is not a knock on Consul but a reflection on our 
use cases and the need to move on to something different.&lt;/p&gt;

&lt;p&gt;For example we binary encode, compress and base64 encode our metadata and service endpoint information 
before storing them as Consul tags because there just wasn’t any other way to do so. We were also very 
heavily abusing the distributed properties of Consul which caused a number of issues with raft consensus.&lt;/p&gt;

&lt;p&gt;Unfortunately we’ve found that its now time to move on.&lt;/p&gt;

&lt;p&gt;Since 2014 kubernetes has really become a reckoning force in the landscape of container orchestration and the 
base level platform for services. With that etcd became their key-value storage of choice, a distributed key-value 
store built with raft consensus. It has evolve to cater to the scale requirements of kubernetes and has since 
been battle tested in a way few other open source projects have.&lt;/p&gt;

&lt;p&gt;Etcd also being a very standard Get/Put/Delete store for binary data means we’re easily able to encode and store 
our service metadata with zero issues. It has no opinions about the format of the data being stored.&lt;/p&gt;

&lt;p&gt;We’ve in the past week moved etcd to become one of the default service discovery mechanisms in Micro and will be 
looking to deprecate Consul in the coming weeks. What does this mean? Well we’ll be moving consul to our 
community maintained &lt;a href=&quot;https://github.com/micro/go-plugins&quot;&gt;go-plugins&lt;/a&gt; repository and focusing on supporting 
etcd.&lt;/p&gt;

&lt;p&gt;We know a number of users are using Consul and this may cause disruption. This to us is a breaking change on our 
path to v2 and so our next release will be tagged as v2. You can be assured that your v1 releases will continue 
to operate as is but expect that the next release we do is micro v2.0.0.&lt;/p&gt;

&lt;center&gt;...&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
To learn more check out the &lt;a href=&quot;https://micro.mu&quot;&gt;website&lt;/a&gt;, follow us on &lt;a href=&quot;https://twitter.com/microhq&quot;&gt;twitter&lt;/a&gt; or 
join the &lt;a href=&quot;https://micro-services.slack.com&quot;&gt;slack&lt;/a&gt; community.&lt;/p&gt;

&lt;h6&gt;&lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt; Micro&lt;/a&gt;&lt;/h6&gt;
</description>
        <pubDate>Fri, 04 Oct 2019 10:00:00 +0100</pubDate>
        <link>https://micro.mu//blog/2019/10/04/deprecating-consul.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2019/10/04/deprecating-consul.html</guid>
        
        
      </item>
    
      <item>
        <title>The end game for developers</title>
        <description>&lt;p&gt;&lt;br /&gt;
Something I often wonder is how we’re stuck in this pre-historic phase of software development. Where technology has largely advanced from a consumer experience standpoint, but as developers it feels like we’re moving at a snails pace.&lt;/p&gt;

&lt;p&gt;The languages of today remain largely unchanged. The frameworks which appear continually offer the same experiences as those that came before them. And every so often we develop new technologies which create a “paradigm shift” which ultimately sets us back 10 years as we have to build the same tools again for new platforms.&lt;/p&gt;

&lt;p&gt;As a developer and former systems engineer, I’m tired. I’m tired of the same old same old. I’m tired of building the same things as I built before. I’m tired of constantly reinventing the wheel because we decided to use a different technology stack or because we want to learn docker, kubernetes, Go or whatever the next new hyped thing is.&lt;/p&gt;

&lt;p&gt;Ultimately I feel like software development is at a standstill. And the reason why we only have 24m developers in the world is because we’re not progressing. We’re not evolving. I believe this has to change.&lt;/p&gt;

&lt;p&gt;I think the end game for developers is really to turn every human being with a mobile device into a developer. This requires a fundamental change in how we design programming languages and tools. It’s a first principles approach no one dares take.&lt;/p&gt;

&lt;p&gt;What is the end game for developers? Let us know your thoughts.&lt;/p&gt;

&lt;center&gt;...&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
To learn more check out the &lt;a href=&quot;https://micro.mu&quot;&gt;website&lt;/a&gt;, follow us on &lt;a href=&quot;https://twitter.com/microhq&quot;&gt;twitter&lt;/a&gt; or 
join the &lt;a href=&quot;https://micro-services.slack.com&quot;&gt;slack&lt;/a&gt; community.&lt;/p&gt;

&lt;h6&gt;&lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt; Micro&lt;/a&gt;&lt;/h6&gt;
</description>
        <pubDate>Thu, 13 Jun 2019 10:00:00 +0100</pubDate>
        <link>https://micro.mu//blog/2019/06/13/the-developer-end-game.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2019/06/13/the-developer-end-game.html</guid>
        
        
      </item>
    
      <item>
        <title>Micro - The great consolidation of 2019</title>
        <description>&lt;p&gt;&lt;br /&gt;
Micro started it’s journey as &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;&lt;strong&gt;go-micro&lt;/strong&gt;&lt;/a&gt; - a microservices framework - focused 
on providing the core requirements for microservice development. It creates a simpler experience for building microservices 
by abstracting away the complexity of distributed systems.&lt;/p&gt;

&lt;p&gt;Over time we’ve expanded beyond go-micro into additional tools, libraries and plugins. This has led to fragmentation 
in the way we solve problems and how developers are expected to use micro tools. We’re now undergoing a consolidation 
of all these tools to simplify the developer experience.&lt;/p&gt;

&lt;p&gt;Micro essentially moves to being a standalone development framework and runtime for microservices development.&lt;/p&gt;

&lt;p&gt;Before we talk about the consolidation, let’s revisit the journey thus far.&lt;/p&gt;

&lt;h2 id=&quot;the-primary-focus&quot;&gt;The Primary Focus&lt;/h2&gt;

&lt;p&gt;Go-micro started out as primarily being focused on the communication aspects of microservices and we’ve tried to remain true to that. 
This opinionated approach and focus is what’s really driven the success of the framework thus far. Over the years 
we’ve had numerous requests to solve the next day problems for building production ready software in go-micro itself. 
Much of this has been related to scalability, security, synchronisation and configuration.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;https://micro.mu/docs/images/go-micro.svg&quot; style=&quot;width: 80%; height: auto;&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;While there would have been merit to add the additional features requested we really wanted to stay very focused 
on solving one problem really well at first. So we took a different approach to promoting the community to do this.&lt;/p&gt;

&lt;h2 id=&quot;ecosystem--plugins&quot;&gt;Ecosystem &amp;amp; Plugins&lt;/h2&gt;

&lt;p&gt;Going to production involves much more than vanilla service discovery, message encoding and request-response. 
We really understood this but wanted to enable users to choose the wider platform requirements via pluggable and 
extensible interfaces. Promoting an ecosystem through an &lt;a href=&quot;https://micro.mu/explore/&quot;&gt;explorer&lt;/a&gt; which aggregates 
micro based open source projects on GitHub along with extensible plugins via the &lt;a href=&quot;https://github.com/micro/go-plugins&quot;&gt;go-plugins&lt;/a&gt; repo.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;https://micro.mu/explorer.png&quot; style=&quot;width: 80%; height: auto;&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;Go Plugins has generally been a great success by allowing developers to offload significant complexity to systems built 
for those requirements e.g prometheus for metrics, zipkin for distributed tracing and kafka for durable messaging.&lt;/p&gt;

&lt;h2 id=&quot;points-of-interaction&quot;&gt;Points of Interaction&lt;/h2&gt;

&lt;p&gt;Go Micro was really at the heart of microservice development but as services were written the next questions moved on to; 
how do I query these, how do I interact with them, how do I serve them by traditional means…&lt;/p&gt;

&lt;p&gt;Given go-micro used an rpc/protobuf based protocol that was both pluggable and runtime agnostic, we needed some way to address 
this in a way that was true to go-micro itself. This led to the creation of &lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;strong&gt;micro&lt;/strong&gt;&lt;/a&gt;, 
the microservice toolkit. Micro provides an api gateway, web dashboard, cli, slack bot, service proxy and much more.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;https://micro.mu/blog/assets/images/runtime3.svg&quot; style=&quot;width: 80%; height: auto;&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;The micro toolkit acted as interaction points via http api, browser, slack commands and command line interface. These 
are common ways in which we query and build on applications and it was important for us to provide a runtime that 
really enabled this. Yet still it really focused on communication above all else.&lt;/p&gt;

&lt;h2 id=&quot;additional-tools&quot;&gt;Additional Tools&lt;/h2&gt;

&lt;p&gt;While the plugins and the toolkit helped users of micro significantly, it still lacked in key areas. It was clear that our community 
wanted us to solve further problems around platform tooling for product development rather than having to do it individually at 
their various companies. We needed the same types of abstractions go-micro provided for things like dynamic configuration, 
distributed synchronization and broader solutions for systems like Kubernetes.&lt;/p&gt;

&lt;p&gt;For these we created:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/micro/go-config&quot;&gt;micro/go-config&lt;/a&gt; - a dynamic configuration library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/asim/go-sync&quot;&gt;micro/go-sync&lt;/a&gt; - a distributed synchronisation library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/micro/kubernetes&quot;&gt;micro/kubernetes&lt;/a&gt; - micro on kubernetes initialisation&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/micro/examples&quot;&gt;examples&lt;/a&gt; - example usage code for micro&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/microhq&quot;&gt;microhq&lt;/a&gt; - a place for prebuilt microservices&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These were a few of the repos, libraries and tools used to attempt to solve the wider requirements of our community. Over the 
4 years the number of repos grew and the getting started experience for new users became much more difficult. The barrier to 
entry increased dramatically and with that we knew something needed to change.&lt;/p&gt;

&lt;h2 id=&quot;consolidation&quot;&gt;Consolidation&lt;/h2&gt;

&lt;p&gt;In the past few weeks we’ve realised &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;&lt;strong&gt;go-micro&lt;/strong&gt;&lt;/a&gt; was really the focal point for most of our users 
developing microservices. It’s become clear they want additional functionality as part of this library and as a self described 
framework we really need to embrace this by solving those next day concerns without asking a developer to go anywhere else.&lt;/p&gt;

&lt;p&gt;Essentially &lt;strong&gt;go-micro&lt;/strong&gt; will be the all encompassing and standalone framework for microservice development.&lt;/p&gt;

&lt;p&gt;We’ve started the consolidation process by moving all our libraries into go-micro and we’ll continue to refactor over the 
coming weeks to provide a simpler default getting started experience while also adding further features for logging, tracing, metrics, 
authentication, etc.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;/blog/assets/images/go-micro-repo.png&quot; style=&quot;width: 80%; height: auto;&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;We’re not forgetting about &lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;strong&gt;micro&lt;/strong&gt;&lt;/a&gt; either though. In our minds after you’ve built your microservices 
there’s still a need for a way to query, run and manage them. &lt;strong&gt;Micro&lt;/strong&gt; is by all accounts going to be the runtime for micro 
service development. We’re working on providing a simpler way to manage the end to end flow of microservice development and 
should have more to announce soon.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Micro is the simplest way to build microservices and slowly becoming the defacto standard for Go based microservice development in 
the cloud. We’re making that process even simpler by consolidating our efforts into a single development framework and runtime.&lt;/p&gt;

&lt;center&gt;...&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
To learn more check out the &lt;a href=&quot;https://micro.mu&quot;&gt;website&lt;/a&gt;, follow us on &lt;a href=&quot;https://twitter.com/microhq&quot;&gt;twitter&lt;/a&gt; or 
join the &lt;a href=&quot;https://micro-services.slack.com&quot;&gt;slack&lt;/a&gt; community.&lt;/p&gt;

&lt;h6&gt;&lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt; Micro&lt;/a&gt;&lt;/h6&gt;
</description>
        <pubDate>Mon, 10 Jun 2019 10:00:00 +0100</pubDate>
        <link>https://micro.mu//blog/2019/06/10/the-great-consolidation.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2019/06/10/the-great-consolidation.html</guid>
        
        
      </item>
    
      <item>
        <title>Micro 1.0.0 release and beyond</title>
        <description>&lt;p&gt;&lt;br /&gt;
Over the past 4 years we’ve focused on creating the simplest experience for microservice development. To do this 
we built a strongly opinionated open source framework called &lt;a href=&quot;https://github.com/micro/go-micro&quot;&gt;&lt;strong&gt;Go Micro&lt;/strong&gt;&lt;/a&gt; and 
&lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;strong&gt;Micro&lt;/strong&gt;&lt;/a&gt;, a microservice toolkit built to explore, query and 
interact with those services via an API Gateway, CLI, Slack and Web Dashboard.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://micro.mu/docs/images/go-micro.svg&quot; style=&quot;max-width: 100%; margin: 0;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;version-100&quot;&gt;Version 1.0.0&lt;/h2&gt;

&lt;p&gt;Last month we released &lt;strong&gt;version 1.0.0&lt;/strong&gt; of both of these tools. This signifies a huge moment for Micro and the community. We’ve been 
running in production since 2015 and have become vital for companies like our sponsor Sixt, the german car rental enterprise, who are 
running hundreds of microservices in production.&lt;/p&gt;

&lt;p&gt;Micro enables teams to scale microservices development while abstracting away the complexity of distributed systems and cloud-native infrastructure. 
It provides a pluggable and runtime agnostic architecture with sane zero dependency defaults.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;https://micro.mu/micro-diag.svg&quot; style=&quot;max-width: 100%; margin: 0;&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
We’ve considered Micro production ready for a long time but the release of 1.0.0 solidifies the maturity and stability of our tooling. And 
we believe it’s the right time for everyone to adopt Micro as the defacto standard for microservice development.&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;Micro has largely grown organically. We’ve not yet actively engaged in speaking at conferences, meetups or any other form of outreach. Instead 
we focused on solving a real problem and it’s shown in the numbers.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;/blog/assets/images/stars.png&quot; style=&quot;max-width: 75%; margin: 0;&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
It’s difficult to track active usage of a library or framework but what’s clear from all we can see is that Micro has really resonated with 
the developer community who want a simpler path to adopting microservices with Go.&lt;/p&gt;

&lt;h2 id=&quot;beyond-10&quot;&gt;Beyond 1.0&lt;/h2&gt;

&lt;p&gt;The announcement of version 1.0.0 is not just a marker for maturity and stability to run Micro in production but it also signals that this release version 
will not suffer any further breaking API changes. This now also allows us to take stock of all the learnings of Micro’s usage of the past 4 
years, how technology has evolved in the industry and what version 2 might start to look like.&lt;/p&gt;

&lt;p&gt;When we started, kubernetes was just in it’s infancy and gRPC had only recently been released. We’re seeing these trends along with service mesh 
and much more.&lt;/p&gt;

&lt;p&gt;Because Micro is pluggable we’ve always been able to adapt to the changing needs of developers while continuing to provide 
simpler abstractions on top for microservice development. With version 2.0 we have the ability to create an even more frictionless and streamlined
experience.&lt;/p&gt;

&lt;p&gt;Some of these ideas will revolve around using gRPC by default, allowing a drop-in experience on kubernetes and potentially a runtime 
for those who don’t want to deal with the complexity of cloud-native systems or any dependency management at all.&lt;/p&gt;

&lt;p&gt;We’ll also be thinking about how to move beyond Go to support multiple languages.&lt;/p&gt;

&lt;h2 id=&quot;collaboration&quot;&gt;Collaboration&lt;/h2&gt;

&lt;p&gt;Slack has served us well for realtime collaboration but we need a medium aligned with open source to push this much further, to be far more inclusive 
and to provide a historic record for newcomers to explore easily.&lt;/p&gt;

&lt;p&gt;We’re going to work with the community by using GitHub to create an open source location to share ideas, discussion and the roadmap for the 
&lt;a href=&quot;https://github.com/micro/development&quot;&gt;&lt;strong&gt;Development&lt;/strong&gt;&lt;/a&gt; of features for 2.0 and beyond.&lt;/p&gt;

&lt;p&gt;To all those interested in contributing and collaboration, create an issue for feature requests, a pull request to share design ideas and we’ll work 
together to shape the roadmap.&lt;/p&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks&lt;/h2&gt;

&lt;p&gt;I want to finish by saying thank you to the Micro community and all who’ve used or supported us over the past 4 years. It’s been a long hard 
but incredibly rewarding journey with so much more left to do. Without the community Micro would not be where it is today. We’re 1.6k+ members 
strong in Slack with thousands more across other forums.&lt;/p&gt;

&lt;center&gt;
&lt;blockquote class=&quot;twitter-tweet&quot; data-cards=&quot;hidden&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Today I released v1 of micro and go-micro. 4 years of hard work. Thanks to all that supported me along the way. &lt;a href=&quot;https://t.co/blI1pJ3hBl&quot;&gt;https://t.co/blI1pJ3hBl&lt;/a&gt;&lt;/p&gt;&amp;mdash; Asim Aslam (@chuhnk) &lt;a href=&quot;https://twitter.com/chuhnk/status/1102992210088378369?ref_src=twsrc%5Etfw&quot;&gt;March 5, 2019&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
Thank you for all your support and contributions. We hope we can return the favour by providing everyone the most inclusive and collaborative 
place for all things microservices.&lt;/p&gt;

&lt;center&gt;...&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
Micro is the simplest way to build microservices. If you’re thinking about microservice development we want to help enable you on that journey. 
To learn more check out the &lt;a href=&quot;https://micro.mu&quot;&gt;website&lt;/a&gt;, follow us on &lt;a href=&quot;https://twitter.com/microhq&quot;&gt;twitter&lt;/a&gt; or 
join the &lt;a href=&quot;https://micro-services.slack.com&quot;&gt;slack&lt;/a&gt; community.&lt;/p&gt;

&lt;h6&gt;&lt;a href=&quot;https://github.com/micro/micro&quot;&gt;&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt; Micro&lt;/a&gt;&lt;/h6&gt;
</description>
        <pubDate>Mon, 01 Apr 2019 10:00:00 +0100</pubDate>
        <link>https://micro.mu//blog/2019/04/01/micro-version-1-and-beyond.html</link>
        <guid isPermaLink="true">https://micro.mu//blog/2019/04/01/micro-version-1-and-beyond.html</guid>
        
        
      </item>
    
  </channel>
</rss>
